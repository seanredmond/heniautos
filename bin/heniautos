#!/usr/bin/env python3

import argparse
import csv
from datetime import datetime
import heniautos as ha
from sys import stdout, exit

def julian_fmt(d):
    return " ".join((bce_as_bce(tuple(d.utc)[0]), d.utc_strftime("%b %d")))


def years(start, end, ce):                            
    """ Return a list of years from START to END inclusive."""
    if end is None:
        # Single year, return a range
        if ce:
            return range(start, start + 1)
        return range(ha.bce_as_negative(start), ha.bce_as_negative(start) + 1)
    if ce:
        if end > start:
            return range(start, end + 1)
    else:
        if end <= start:
            # multiple years, return as range
            return range(ha.bce_as_negative(start), ha.bce_as_negative(end) + 1)

    raise ValueError("End year must be later than the start year")

def get_rule(r):
    if r == "0":
        return ha.Visible.CONJUNCTION

    if r == "1":
        return ha.Visible.NEXT_DAY

    if r == "d":
        return ha.Visible.DINSMOOR

    return ha.Visible.SECOND_DAY


def month_n(m, int_m, abbrev, greek=False):
    if abbrev:
        n = month_name(m, int_m, greek).split(" ")
        if len(n) > 1:
            return f"{n[0][0:3]} II"

        return n[0][0:3]
        
    return month_name(m, int_m, greek)


def arkhon_year(y):
    eet = ha.as_eet(y)
    epoch = eet[:3]
    year1 = int(eet[4:8])
    year2 = year1 - 1 if epoch == "BCE" else year1 + 1
    return f"{epoch} {year1}/{year2}"


def output_daily(y, writer, args):
    for year in y:
        ay = arkhon_year(year[0]["days"][0]["date"])
        for month in year:
            for day in month["days"]:
                writer.writerow((
                    ay,
                    month["month"],
                    day["day"],
                    ha.as_eet(day["date"]),
                    day["doy"]))


def output_monthly(y, writer, args):
    for year in y:
        ay = arkhon_year(year[0]["days"][0]["date"])
        for month in year:
            writer.writerow((
                ay,
                month["month"],
                ha.as_eet(month["days"][0]["date"]),
                len(month["days"])))


def output_yearly(y, writer, args):
    for year in y:
        writer.writerow((arkhon_year(year[0]["days"][0]["date"]),
                         "I" if len(year) > 12 else "O",
                         ha.as_eet(year[0]["days"][0]["date"]),
                         sum(len(m["days"]) for m in year)))

            




if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("start_year", type=int)
    parser.add_argument("end_year", type=int, nargs='?', default=None)
    parser.add_argument("-m", "--month-summary", action="store_true")
    parser.add_argument("-y", "--year-summary", action="store_true")
    parser.add_argument("--intercalate", type=int, default=5,
                        help="Month after which to intercalate")
    parser.add_argument("--as-ce", action="store_true",
                       help="Treat dates as CE rather than BCE")
    parser.add_argument("-a", "--abbreviations", action="store_true",
                        help="Abbreviate month names")
    parser.add_argument("-g", "--greek-names", action="store_true",
                        help="Use Greek names for months")
    parser.add_argument("--new-moons", action="store_true",
                        help="Only list times of astronomical new moons")
    parser.add_argument("--solstices", action="store_true",
                        help="Only list dates of solstices")
    parser.add_argument("--utc", action="store_true",
                        help="Format times as UTC (rather than EET)")
    parser.add_argument("-r", "--rule", choices=["0", "1", "2", "d"],
                        default="2", type=str,
                        help="Rule for determining date of new moon. "
                        "0, 1, 2 days after astronomical conjunction, or "
                        "d for Dinsmoor"
                        "(default: 2)")
    args = parser.parse_args()
    
    ha.init_data()
    writer = csv.writer(stdout, delimiter="\t", quoting=csv.QUOTE_NONNUMERIC)

    if args.new_moons:
        for year in years(args.start_year, args.end_year, args.as_ce):
            for nm in ha.new_moons(year):
                if args.utc:
                    print(ha.as_utc(nm, True))
                else:
                    print(ha.as_eet(nm, True))
        exit()

    if args.solstices:
        for year in years(args.start_year, args.end_year, args.as_ce):
            if args.utc:
                print(ha.as_utc(ha.summer_solstice(year), True))
            else:
                print(ha.as_eet(ha.summer_solstice(year), True))
        exit()
    
    year = [ha.festival_calendar(y, abbrev=args.abbreviations,
                                 greek=args.greek_names,
                                 intercalate=args.intercalate - 1,
                                 rule=get_rule(args.rule))
            for y in years(args.start_year, args.end_year, args.as_ce)]

    if args.year_summary:
        output_yearly(year, writer, args)
        exit()

    if args.month_summary:
        output_monthly(year, writer, args)
        exit()
        
    output_daily(year, writer, args)
