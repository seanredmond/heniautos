#!/usr/bin/env python3

import argparse
import csv
from datetime import datetime
from heniautos import *
from sys import stdout, exit

def parse_date(d):
    # Acceptable:
    # Jun 28, June 28, 06/28
    for fmt in ("%b %d", "%B %d", "%m/%d", "%m-%d"):
        try:
            return datetime.strptime(d, fmt).timetuple()[1:3]
        except ValueError:
            pass

    raise ValueError("Could not parse '{d}' as a date")


def julian_fmt(d):
    return " ".join((bce_as_bce(tuple(d.utc)[0]), d.utc_strftime("%b %d")))


def years(start, end, ce):                            
    """ Return a list of years from START to END inclusive."""
    if end is None:
        # Single year, return a range
        if ce:
            return range(start, start + 1)
        return range(bce_as_negative(start), bce_as_negative(start) + 1)
    if ce:
        if end > start:
            return range(start, end + 1)
    else:
        if end <= start:
            # multiple years, return as range
            return range(bce_as_negative(start), bce_as_negative(end) + 1)

    raise ValueError("End year must be later than the start year")


def month_n(m, int_m, abbrev, greek=False):
    if abbrev:
        n = month_name(m, int_m, greek).split(" ")
        if len(n) > 1:
            return f"{n[0][0:3]} II"

        return n[0][0:3]
        
    return month_name(m, int_m, greek)

def output_daily(y, writer, args):
    for year in y:
        int_m = args.intercalate if year["intercalated"] else None
        for month in year["calendar"]:
            for day in month["days"]:
                writer.writerow((
                    julian_fmt(day["date"]),
                    month["month"],
                    month_n(month["month"], int_m, args.abbreviations,
                            args.greek_names),
                    day["day"],
                    festival(month_n(month["month"], int_m,
                                     False, True),
                             day["day"])))


def output_monthly(y, writer, args):
    for year in y:
        # # for s in year["solstices"]:
        # #     print(s.utc_jpl())
        int_m = args.intercalate if year["intercalated"] else None
        for month in year["calendar"]:
            writer.writerow((
                bce_as_bce(tuple(month["days"][0]["date"].utc)[0]),
                month["days"][0]["date"].utc_strftime("%b %d"),
                month_n(month["month"], int_m, args.abbreviations,
                        args.greek_names),
                len(month["days"]),
                
            ))


def output_yearly(y, writer, args):
    for year in y:
        writer.writerow((
            utc_as_arkhon(year["calendar"][0]["days"][0]["date"]),
            "I" if year["intercalated"] else "O",
            year["calendar"][0]["days"][0]["date"].utc_strftime("%b %d"),
            sum([len(m["days"]) for m in year["calendar"]]),
            year_as_pattern([len(m["days"]) for m in year["calendar"]])
        ))

            




if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("start_year", type=int)
    parser.add_argument("end_year", type=int, nargs='?', default=None)
    parser.add_argument("-m", "--month-summary", action="store_true")
    parser.add_argument("-y", "--year-summary", action="store_true")
    parser.add_argument("--pattern", type=str)
    parser.add_argument("--start-day", type=str)
    parser.add_argument("--intercalate", type=int, default=6,
                        help="Month after which to intercalate")
    parser.add_argument("--as-ce", action="store_true",
                       help="Treat dates as CE rather than BCE")
    parser.add_argument("-a", "--abbreviations", action="store_true",
                        help="Abbreviate month names")
    parser.add_argument("--greek-names", action="store_true",
                        help="Use Greek names for months")
    parser.add_argument("--new-moons", action="store_true",
                        help="Only list times of astronomical new moons")
    parser.add_argument("--solstices", action="store_true",
                        help="Only list dates of solstices")
    parser.add_argument("--utc", action="store_true",
                        help="Format times as UTC (rather than EET)")
    parser.add_argument("--min-lunar-illumination", type=float, default=3.0)
    args = parser.parse_args()
    
    #print(args)

    writer = csv.writer(stdout, delimiter="\t", quoting=csv.QUOTE_NONNUMERIC)
    ts = api.load.timescale()
    ts.julian_calendar_cutoff = GREGORIAN_START
    eph = api.load('de422.bsp')

    if args.new_moons:
        for year in years(args.start_year, args.end_year, args.as_ce):
            for nm in new_moons0(year):
                if args.utc:
                    print(as_utc(nm))
                else:
                    print(as_eet(nm))
        exit()

    if args.solstices:
        for year in years(args.start_year, args.end_year, args.as_ce):
            if args.utc:
                print(as_utc(sum_sol(year)))
            else:
                print(as_eet(sum_sol(year)))
        exit()
    
    if not args.start_day:
        year = [months_of_year(y, args.min_lunar_illumination)
                for y in years(args.start_year, args.end_year, args.as_ce)]

        if args.year_summary:
            output_yearly(year, writer, args)
        elif args.month_summary:
            output_monthly(year, writer, args)
        else:
            output_daily(year, writer, args)
                
    if args.start_day:
        start_y = bce_as_negative(args.start_year)
        start_m, start_d = parse_date(args.start_day)
        start_at = heniautos.utc(start_y, start_m, start_d)

        if args.pattern:
            output_daily(
                heniautos.year_from_pattern(start_at, args.pattern),
                writer)
                        

    
